# OS

## 운영체제 개요

### 운영체제가 하는 일

- 프로세스 관리
- 메모리 관리
- 하드웨어 관리
- 파일 시스템 관리

### 운영체제의 발전

- 어떻게 하면 CPU를 효율적으로 사용할 수 있을까?
- 낭비되는 시간을 줄인다.
- CPU의 사용률을 높이는 방법

### 운영체제의 구조

- 커널
  - 사용자
    - 인터페이스를 통해 접근
    - CLI, GUI
  - 어플리케이션
    - 시스템 콜을 통해 커널에 접근
  - 하드웨어
    - 드라이버를 통해 커널에 접근

### 하드웨어 구조

- 폰노이만 구조

  - CPU와 메모리를 연결하는 버스
  - 메모리의 소프트웨를 저장해 사용

- 메인보드

  - CPU
  - 메모리
  - 주변 장치

- CPU

  - ALU
    - 실제 연산 수행
  - CU
    - 장치들의 동작 제어
  - 레지스터
    - 데이터를 임시 보관

- 메모리
  - RAM
    - Random Access Memory
    - 데이터를 빠르게 읽고 쓸 수 있는 메모리
    - 휘발성 메모리
    - 프로세스가 실행되는 메모리
  - ROM
    - Read Only Memory
    - 데이터를 읽을 수만 있고 쓸 수 없는 메모리
    - 비휘발성 메모리
    - BIOS(컴퓨터 부팅을 위한 프로그램)

## 프로세스와 쓰레드

### 프로그램과 프로세스

- 프로그램
  - 저장장치에 저장된 명령의 집합체(코드와 데이터)

- 프로세스
  - 실행 중인 프로그램
  - 프로그램이 메모리에 로드된 상태
  - CPU가 실행하는 단위

### 프로세스의 구조
- Code 영역
  - 실행되는 코드가 저장된 영역
- Data 영역
  - 전역 변수와 정적 변수가 저장된 영역
- Stack 영역
  - 지역변수
  - 함수 호출과 관련된 정보가 저장된 영역
- Heap 영역
  - 동적으로 할당된 메모리가 저장된 영역
  - new / malloc() / free()

### 컴파일 과정

- 전처리기
  - 필요한 전처리와 매크로를 처리
- 컴파일
  - 고수준의 프로그래밍 언어를 저수준의 어셈블리어로 변환
- 어셈블러
  - 어셈블리어를 기계어로 변환
- 링커
  - 여러 개의 객체 파일을 하나의 실행 파일로 변환

### CPU 관점에서 보는 프로세스 실행
```Java
int num1 = 5;
int num2 = 6;
int result = num1 + num2;
```
- 제어장치가 명령어를 읽고 num1, num2를 읽고 레지스터에 저장
- ALU가 num1과 num2를 더하고 결과를 레지스터에 저장
- 제어장치가 레지스터에서 결과를 가져와서 메모리에 저장

### 멀티프로그래밍과 멀티프로세싱

- 멀티프로그래밍
  - 메모리에 여러 프로그램이 동시에 실행
  - CPU가 프로세스를 번갈아가며 실행

- 멀티프로세싱
  - 여러 개의 CPU가 동시에 실행
  - 여러 개의 프로세스를 동시에 실행, 다대다

- PCB(Process Control Block)
  - 프로세스의 상태를 관리하는 구조체
  - 프로세스의 메모리 주소
  - 프로세스의 상태
  - 프로세스의 우선순위
  - 프로세스의 ID

### 프로세스의 상태

- 생성
- 준비
- 대기
- 실행
- 종료

준비와 실행을 스케줄링에 따라 반복
대기상태 : 입출력 대기

### 컨텍스트 스위칭

- 현재 프로세스가 실행 중인 상태를 저장
- 다음 프로세스가 실행 중인 상태를 복구
- 실행
- CPU 점유시간, 인터럽트로 인해 발생

### 프로세스 생성

- 더블클릭
- 빈 스택, 빈 힙 생성
- PCB 생성
- 이후 생성되는 프로세스들은 부팅시 실행되는 0번 프로세스를 복사해서 실행